<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ë””ì§€í„¸ íœ´ì‹ & ìŠ¤íŠ¸ë ˆì¹­ íƒ€ì´ë¨¸</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for the circular progress bar effect */
        .timer-circle {
            position: relative;
            width: 300px;
            height: 300px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1), 0 1px 3px rgba(0, 0, 0, 0.08);
            margin: 2rem auto;
            background: conic-gradient(currentColor 0%, transparent 0%);
            transition: background 0.5s ease-in-out;
        }

        .timer-circle-inner {
            width: 280px;
            height: 280px;
            border-radius: 50%;
            background-color: #1f2937; /* Dark background */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            padding: 1rem;
        }

        /* Mobile adjustments */
        @media (max-width: 640px) {
            .timer-circle {
                width: 240px;
                height: 240px;
                margin: 1.5rem auto;
            }
            .timer-circle-inner {
                width: 220px;
                height: 220px;
            }
            .time-display {
                font-size: 3.5rem !important;
            }
        }
    </style>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                }
            }
        }
    </script>
</head>
<body class="bg-gray-900 min-h-screen flex items-center justify-center p-4 font-sans text-gray-100">

    <div class="w-full max-w-lg bg-gray-800 p-6 sm:p-8 rounded-xl shadow-2xl">
        <h1 class="text-3xl font-extrabold text-center mb-6 text-indigo-400">ë””ì§€í„¸ íœ´ì‹ íƒ€ì´ë¨¸</h1>
        <p class="text-center text-sm mb-6 text-gray-400">ëˆˆ ê±´ê°•ê³¼ ê±°ë¶ëª© ì˜ˆë°©ì„ ìœ„í•œ ì‚¬ìš© & íœ´ì‹ íƒ€ì´ë¨¸</p>

        <!-- New Gemini Feature: Focus Mode Tip -->
        <div class="bg-gray-700 p-4 rounded-xl mb-6 shadow-inner border border-gray-600">
            <h2 class="text-lg font-semibold text-indigo-300 mb-2">âœ¨ ë‹¤ìŒ ì‚¬ìš© ì‹œê°„ ì§‘ì¤‘ íŒ</h2>
            <p id="focus-tip-output" class="text-base text-gray-300 min-h-[1.5rem]">
                íŒì„ ë¡œë“œí•˜ëŠ” ì¤‘...
            </p>
        </div>

        <!-- Settings Section -->
        <div class="bg-gray-700 p-4 rounded-lg mb-6 shadow-inner">
            <div class="flex flex-col sm:flex-row justify-around space-y-4 sm:space-y-0 sm:space-x-4">
                <div class="flex flex-col w-full">
                    <label for="work-duration" class="text-sm font-medium mb-1 text-indigo-300">ì‚¬ìš© ì‹œê°„ (ë¶„)</label>
                    <input type="number" id="work-duration" value="50" min="5" class="p-2 rounded-lg bg-gray-600 border border-gray-500 focus:ring-indigo-500 focus:border-indigo-500 text-white" onchange="updateSettings()">
                </div>
                <div class="flex flex-col w-full">
                    <label for="break-duration" class="text-sm font-medium mb-1 text-green-300">íœ´ì‹ ì‹œê°„ (ë¶„)</label>
                    <input type="number" id="break-duration" value="10" min="1" class="p-2 rounded-lg bg-gray-600 border border-gray-500 focus:ring-green-500 focus:border-green-500 text-white" onchange="updateSettings()">
                </div>
            </div>
        </div>

        <!-- Timer Display Area -->
        <div id="timer-circle" class="timer-circle text-indigo-500" style="--progress: 100%;">
            <div class="timer-circle-inner">
                <div id="phase-display" class="text-xl font-semibold mb-2 text-indigo-400">ì‚¬ìš© ì‹œê°„</div>
                <div id="time-display" class="time-display text-6xl sm:text-7xl font-mono font-bold">50:00</div>
            </div>
        </div>

        <!-- Control Buttons -->
        <div class="flex justify-center space-x-4">
            <button id="start-btn" onclick="startTimer()" class="px-6 py-3 bg-indigo-600 hover:bg-indigo-700 text-white font-bold rounded-full shadow-lg transition duration-200 active:scale-95">
                ì‹œì‘
            </button>
            <button id="pause-btn" onclick="pauseTimer()" class="px-6 py-3 bg-yellow-600 hover:bg-yellow-700 text-white font-bold rounded-full shadow-lg transition duration-200 active:scale-95 hidden">
                ì¼ì‹œ ì •ì§€
            </button>
            <button id="reset-btn" onclick="resetTimer()" class="px-6 py-3 bg-gray-600 hover:bg-gray-700 text-white font-bold rounded-full shadow-lg transition duration-200 active:scale-95">
                ì´ˆê¸°í™”
            </button>
        </div>
        
        <!-- Break Notification Modal (Custom Alert) -->
        <div id="break-modal" class="fixed inset-0 bg-black bg-opacity-70 backdrop-blur-sm hidden flex items-center justify-center p-4 z-50">
            <div class="bg-gray-800 rounded-xl p-8 shadow-2xl max-w-sm w-full border-4 border-green-500 transform scale-100 transition-transform duration-300 ease-out">
                <h3 class="text-4xl font-extrabold text-green-400 mb-4 text-center">ğŸ”” íœ´ì‹ ì‹œê°„ì…ë‹ˆë‹¤!</h3>
                <p id="modal-message" class="text-lg text-gray-300 mb-4 text-center">
                    ì§€ê¸ˆ ë°”ë¡œ ì¼ì–´ë‚˜ì„œ ëˆˆê³¼ ëª© ìŠ¤íŠ¸ë ˆì¹­ì„ í•´ì£¼ì„¸ìš”.
                </p>
                
                <!-- New Gemini Feature: Stretching Suggestion -->
                <div class="bg-gray-700 p-4 rounded-lg mb-6 border border-gray-600">
                    <p id="stretching-tip-output" class="text-sm text-gray-400 italic min-h-[4rem] flex items-center justify-center text-center">
                        âœ¨ ë²„íŠ¼ì„ ëˆŒëŸ¬ ë§ì¶¤ ìŠ¤íŠ¸ë ˆì¹­ ê°€ì´ë“œë¥¼ ë°›ì•„ë³´ì„¸ìš”!
                    </p>
                    <div class="text-center mt-3">
                        <button id="generate-stretching-btn" onclick="generateStretchingTip()" class="px-4 py-2 bg-indigo-500 hover:bg-indigo-600 text-white font-bold text-sm rounded-full shadow transition duration-200 active:scale-95 disabled:opacity-50">
                            âœ¨ ìŠ¤íŠ¸ë ˆì¹­ ì œì•ˆ ë°›ê¸°
                        </button>
                    </div>
                </div>

                <div class="text-center">
                    <button onclick="dismissModal()" class="px-8 py-3 bg-green-600 hover:bg-green-700 text-white font-bold rounded-full shadow-xl transition duration-300 active:scale-95">
                        íœ´ì‹ ì‹œì‘
                    </button>
                </div>
            </div>
        </div>

    </div>

    <script>
        // --- Timer State Variables ---
        const ONE_MINUTE = 60;
        let workDuration = 50 * ONE_MINUTE; // Default 50 minutes
        let breakDuration = 10 * ONE_MINUTE; // Default 10 minutes
        let totalTime = workDuration;
        let timeLeft = workDuration;
        let timerInterval = null;
        let isWorking = true; // true: Work phase, false: Break phase
        let isPaused = true;

        // --- DOM Elements ---
        const timeDisplay = document.getElementById('time-display');
        const phaseDisplay = document.getElementById('phase-display');
        const timerCircle = document.getElementById('timer-circle');
        const startBtn = document.getElementById('start-btn');
        const pauseBtn = document.getElementById('pause-btn');
        const workInput = document.getElementById('work-duration');
        const breakInput = document.getElementById('break-duration');
        const breakModal = document.getElementById('break-modal');
        
        // --- Gemini API Elements ---
        const generateStretchingBtn = document.getElementById('generate-stretching-btn');
        const stretchingTipOutput = document.getElementById('stretching-tip-output');
        const focusTipOutput = document.getElementById('focus-tip-output');

        // --- Gemini API Configuration ---
        const API_KEY = "";
        const API_URL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=" + API_KEY;

        // --- Utility Functions ---

        /**
         * Formats seconds into MM:SS string.
         * @param {number} seconds - The number of seconds remaining.
         */
        function formatTime(seconds) {
            const minutes = String(Math.floor(seconds / 60)).padStart(2, '0');
            const secs = String(seconds % 60).padStart(2, '0');
            return `${minutes}:${secs}`;
        }

        /**
         * Updates the display elements (time, phase, circle progress).
         */
        function updateDisplay() {
            timeDisplay.textContent = formatTime(timeLeft);

            // Calculate progress percentage for the circular gradient
            const progress = (timeLeft / totalTime) * 100;

            // Set colors and text based on phase
            const phaseColor = isWorking ? 'text-indigo-500' : 'text-green-500';
            const phaseText = isWorking ? 'ì‚¬ìš© ì‹œê°„' : 'íœ´ì‹ ì‹œê°„ (ìŠ¤íŠ¸ë ˆì¹­)'
            const progressColor = isWorking ? '#818CF8' : '#10B981'; // Tailwind Indigo-400 / Green-500

            // Update Circle Color
            timerCircle.classList.remove('text-indigo-500', 'text-green-500');
            timerCircle.classList.add(phaseColor);

            // Update Progress Bar
            timerCircle.style.background = `conic-gradient(${progressColor} ${progress}%, transparent ${progress}%)`;

            // Update Phase Text
            phaseDisplay.textContent = phaseText;
            phaseDisplay.classList.remove('text-indigo-400', 'text-green-400');
            phaseDisplay.classList.add(isWorking ? 'text-indigo-400' : 'text-green-400');
        }

        /**
         * Plays a simple beep sound using the Web Audio API.
         */
        function playBeep() {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(440, audioContext.currentTime); // A4 note
                gainNode.gain.setValueAtTime(0.5, audioContext.currentTime);

                oscillator.start();
                gainNode.gain.exponentialRampToValueAtTime(0.0001, audioContext.currentTime + 1);
                oscillator.stop(audioContext.currentTime + 1);
            } catch (e) {
                console.error("Audio playback failed:", e);
                // Fallback for environments where AudioContext might be restricted
            }
        }

        /**
         * Fetches content from the Gemini API with exponential backoff.
         * @param {string} prompt - The user query for the LLM.
         * @param {string} systemInstruction - The system instruction to guide the model.
         * @param {boolean} useGrounding - Whether to use Google Search for grounding.
         * @returns {Promise<string>} The generated text.
         */
        async function fetchGeminiContent(prompt, systemInstruction, useGrounding = false) {
            let delay = 1000;
            const maxRetries = 3;

            const payload = {
                contents: [{ parts: [{ text: prompt }] }],
                systemInstruction: { parts: [{ text: systemInstruction }] },
            };

            if (useGrounding) {
                payload.tools = [{ "google_search": {} }];
            }

            const headers = { 'Content-Type': 'application/json' };

            for (let i = 0; i < maxRetries; i++) {
                try {
                    const response = await fetch(API_URL, {
                        method: 'POST',
                        headers: headers,
                        body: JSON.stringify(payload)
                    });

                    if (response.ok) {
                        const result = await response.json();
                        const text = result.candidates?.[0]?.content?.parts?.[0]?.text;
                        if (text) {
                            return text.trim();
                        }
                        throw new Error("Empty response from API.");
                    } else if (response.status === 429 && i < maxRetries - 1) {
                        // Rate limit error, wait and retry
                        await new Promise(resolve => setTimeout(resolve, delay));
                        delay *= 2; // Exponential backoff
                    } else {
                        throw new Error(`API request failed with status: ${response.status}`);
                    }
                } catch (error) {
                    if (i === maxRetries - 1) {
                        console.error("Gemini API call failed after multiple retries:", error);
                        return "ì£„ì†¡í•©ë‹ˆë‹¤. í˜„ì¬ AI íŒì„ ìƒì„±í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.";
                    }
                }
            }
            return "ì£„ì†¡í•©ë‹ˆë‹¤. í˜„ì¬ AI íŒì„ ìƒì„±í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.";
        }

        // --- Gemini Feature Functions ---

        /**
         * Generates a specific stretching tip for the break modal.
         */
        async function generateStretchingTip() {
            generateStretchingBtn.disabled = true;
            stretchingTipOutput.innerHTML = '<span class="animate-pulse">âœ¨ ìƒˆë¡œìš´ ìŠ¤íŠ¸ë ˆì¹­ ì œì•ˆì„ ë°›ëŠ” ì¤‘...</span>';

            const systemPrompt = "ë‹¹ì‹ ì€ ì‚¬ìš©ì ì¹œí™”ì ì¸ ê±´ê°• ì½”ì¹˜ì…ë‹ˆë‹¤. ì‚¬ìš©ìì˜ ë””ì§€í„¸ íœ´ì‹ì„ ë•ê¸° ìœ„í•´ ê°„ê²°í•˜ê³  ì‹¤ìš©ì ì¸ ìŠ¤íŠ¸ë ˆì¹­(ëª©, ëˆˆ, ì–´ê¹¨) ë˜ëŠ” ê±´ê°• ìŠµê´€(ìˆ˜ë¶„ ì„­ì·¨, ì ê¹ ê±·ê¸°) ì¤‘ í•˜ë‚˜ë¥¼ ë¬´ì‘ìœ„ë¡œ ì œì•ˆí•´ ì£¼ì„¸ìš”. ë‹µë³€ì€ ì œëª© ì—†ì´ 30ì ì´ë‚´ì˜ ë‹¨ì¼ ë¬¸ì¥ìœ¼ë¡œ í•œêµ­ì–´ë¡œ ì‘ì„±í•´ì•¼ í•©ë‹ˆë‹¤.";
            const userQuery = "ì»´í“¨í„°ë‚˜ íœ´ëŒ€í° ì‚¬ìš© í›„ 5~10ë¶„ê°„ í•  ìˆ˜ ìˆëŠ” ì‰¬ìš´ íœ´ì‹ í™œë™(ìŠ¤íŠ¸ë ˆì¹­ ë˜ëŠ” ê±´ê°• íŒ)ì„ í•˜ë‚˜ë§Œ ì œì•ˆí•´ ì¤˜.";

            const tip = await fetchGeminiContent(userQuery, systemPrompt, false);
            
            stretchingTipOutput.textContent = tip;
            generateStretchingBtn.disabled = false;
        }

        /**
         * Loads a productivity tip for the next work session.
         */
        async function loadFocusTip() {
            focusTipOutput.innerHTML = '<span class="animate-pulse">âœ¨ ì§‘ì¤‘ íŒì„ ë¡œë“œí•˜ëŠ” ì¤‘...</span>';
            
            const systemPrompt = "ë‹¹ì‹ ì€ ì „ë¬¸ì ì¸ ìƒì‚°ì„± ì½”ì¹˜ì…ë‹ˆë‹¤. ì‚¬ìš©ìì˜ ë‹¤ìŒ ì‘ì—… ì„¸ì…˜ ì§‘ì¤‘ë„ë¥¼ ë†’ì´ê¸° ìœ„í•œ ê°„ê²°í•˜ê³  ê°•ë ¥í•œ 'ì§‘ì¤‘ íŒ' ë˜ëŠ” 'ìƒì‚°ì„± íŒ'ì„ í•˜ë‚˜ë§Œ ì œì•ˆí•´ ì£¼ì„¸ìš”. ë‹µë³€ì€ ì œëª© ì—†ì´ 20ì ì´ë‚´ì˜ ë‹¨ì¼ ë¬¸ì¥ìœ¼ë¡œ í•œêµ­ì–´ë¡œ ì‘ì„±í•´ì•¼ í•©ë‹ˆë‹¤.";
            const userQuery = "ë‹¤ìŒ ì‘ì—… ì‹œê°„ 50ë¶„ ë™ì•ˆ ì§‘ì¤‘ë ¥ì„ ìœ ì§€í•˜ê¸° ìœ„í•œ ì§§ì€ ì¡°ì–¸ì„ í•˜ë‚˜ë§Œ ì•Œë ¤ì¤˜.";

            const tip = await fetchGeminiContent(userQuery, systemPrompt, true);
            
            focusTipOutput.textContent = tip;
        }


        // --- Core Timer Logic ---

        /**
         * Main function to decrement time and handle phase transition.
         */
        function tick() {
            if (timeLeft > 0) {
                timeLeft--;
                updateDisplay();
            } else {
                // Time's up!
                clearInterval(timerInterval);
                timerInterval = null; // ë²„ê·¸ ìˆ˜ì •: íƒ€ì´ë¨¸ê°€ ëë‚¬ì„ ë•Œ IDë¥¼ nullë¡œ ì¬ì„¤ì •í•´ì•¼ ë‹¤ìŒ íƒ€ì´ë¨¸ê°€ ì‹œì‘ë¨.
                playBeep();
                showModal(); // Show the custom notification

                // Toggle phase
                isWorking = !isWorking;
                totalTime = isWorking ? workDuration : breakDuration;
                timeLeft = totalTime;

                // Update controls for the next phase
                pauseBtn.classList.add('hidden');
                startBtn.classList.remove('hidden');
                isPaused = true;
                updateDisplay(); // Immediately show the new phase time
                
                // Load new focus tip when transitioning back to work phase
                if (isWorking) {
                    loadFocusTip();
                }
            }
        }

        // --- Control Functions ---

        /**
         * Starts or resumes the timer.
         */
        function startTimer() {
            if (!timerInterval) {
                timerInterval = setInterval(tick, 1000);
                isPaused = false;
                startBtn.classList.add('hidden');
                pauseBtn.classList.remove('hidden');
            }
        }

        /**
         * Pauses the timer.
         */
        function pauseTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
                isPaused = true;
                startBtn.classList.remove('hidden');
                pauseBtn.classList.add('hidden');
            }
        }

        /**
         * Resets the timer back to the initial work phase.
         */
        function resetTimer() {
            pauseTimer();
            isWorking = true;
            updateSettings(); // Recalculate duration from inputs
            timeLeft = totalTime;
            isPaused = true;
            startBtn.classList.remove('hidden');
            pauseBtn.classList.add('hidden');
            updateDisplay();
            
            // Reload focus tip when resetting the timer
            loadFocusTip();
        }

        /**
         * Reads duration inputs and updates total time variables.
         */
        function updateSettings() {
            const newWorkMin = parseInt(workInput.value, 10);
            const newBreakMin = parseInt(breakInput.value, 10);

            if (newWorkMin > 0 && newBreakMin > 0) {
                workDuration = newWorkMin * ONE_MINUTE;
                breakDuration = newBreakMin * ONE_MINUTE;

                // Only update totalTime if the timer is paused or on reset
                if (isPaused) {
                    totalTime = isWorking ? workDuration : breakDuration;
                    timeLeft = totalTime;
                    updateDisplay();
                }
            }
        }

        // --- Modal Functions (Custom Alert) ---

        /**
         * Shows the custom break notification modal.
         */
        function showModal() {
            const message = isWorking
                ? `ğŸ’» ì‚¬ìš© ì‹œê°„ì´ ëë‚¬ìŠµë‹ˆë‹¤. ì¼ì–´ë‚˜ì„œ ${Math.floor(breakDuration / 60)}ë¶„ê°„ ëˆˆ/ëª© ìŠ¤íŠ¸ë ˆì¹­ì„ í•´ì£¼ì„¸ìš”!`
                : "ğŸ§˜ íœ´ì‹ ì‹œê°„ì´ ëë‚¬ìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì§‘ì¤‘í•  ì‹œê°„ì´ì—ìš”. í˜ë‚´ì„¸ìš”!";

            document.getElementById('modal-message').textContent = message;
            
            // Update button text for better context
            const modalButton = breakModal.querySelector('button');
            modalButton.textContent = isWorking ? 'íœ´ì‹ ì‹œì‘' : 'ë‹¤ì‹œ ì§‘ì¤‘';

            breakModal.classList.remove('hidden');

            // Reset stretching tip output every time modal is shown
            stretchingTipOutput.textContent = 'âœ¨ ë²„íŠ¼ì„ ëˆŒëŸ¬ ë§ì¶¤ ìŠ¤íŠ¸ë ˆì¹­ ê°€ì´ë“œë¥¼ ë°›ì•„ë³´ì„¸ìš”!';
            generateStretchingBtn.disabled = false;

            // Apply attention-grabbing animation
            const modalContent = breakModal.querySelector('div:first-child');
            modalContent.classList.remove('scale-100');
            modalContent.classList.add('scale-105');
            setTimeout(() => {
                modalContent.classList.remove('scale-105');
                modalContent.classList.add('scale-100');
            }, 300);
        }

        /**
         * Dismisses the modal and automatically starts the next phase (Break or Work).
         */
        function dismissModal() {
            breakModal.classList.add('hidden');
            startTimer();
        }


        // --- Initialization ---
        window.onload = function() {
            // Ensure initial display is correct based on default settings
            updateSettings();
            updateDisplay();
            // Add event listeners to inputs to update settings dynamically
            workInput.addEventListener('change', updateSettings);
            breakInput.addEventListener('change', updateSettings);
            
            // Load initial Focus Tip using Gemini
            loadFocusTip();
        }

    </script>

</body>
</html>
